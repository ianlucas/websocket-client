{"mappings":"AAkEA,yCAAyC,GAAG,EAAE,MAAM;sBAE9B,MAAM,UAAU,MAAM;;;;;;EAI3C","sources":["src/src/websocketClient.ts","src/websocketClient.ts"],"sourcesContent":[null,"function createEventEmitter() {\r\n  const callbacks = {};\r\n  return {\r\n    on(type: string, handler: Function) {\r\n      if (!callbacks[type]) {\r\n        callbacks[type] = [];\r\n      }\r\n      callbacks[type].push(handler);\r\n    },\r\n\r\n    emit(type: string, ...args: any[]) {\r\n      if (callbacks[type]) {\r\n        callbacks[type].forEach((handler: Function) => {\r\n          handler(...args);\r\n        });\r\n      }\r\n    }\r\n  };\r\n}\r\n\r\nfunction createRoom(url: string, roomType: string, roomId: string) {\r\n  const emitter = createEventEmitter();\r\n  const ws = new WebSocket(url + '/' + roomType + '/' + roomId);\r\n\r\n  function handleMessage(event: MessageEvent) {\r\n    const data = JSON.parse(event.data);\r\n    switch (data.type) {\r\n      case 'state':\r\n        emitter.emit('state', data.value);\r\n        break;\r\n      default:\r\n        throw new Error('Invalid message type sent by server.');\r\n    }\r\n  }\r\n\r\n  function handleClose(event: CloseEvent) {\r\n    emitter.emit('close', event.reason);\r\n  }\r\n\r\n  ws.addEventListener('close', handleClose);\r\n  ws.addEventListener('message', handleMessage);\r\n\r\n  return {\r\n    onStateChange(callback: (state: any) => void) {\r\n      emitter.on('state', callback);\r\n    },\r\n\r\n    onClose(callback: () => void) {\r\n      emitter.on('close', callback);\r\n    },\r\n\r\n    send(type: string, value: any) {\r\n      ws.send(\r\n        JSON.stringify({\r\n          type,\r\n          value\r\n        })\r\n      );\r\n    },\r\n\r\n    close() {\r\n      ws.close();\r\n    }\r\n  };\r\n}\r\n\r\nexport function connectToWebSocketServer(url: string) {\r\n  return {\r\n    getRoom(roomType: string, roomId: string) {\r\n      return createRoom(url, roomType, roomId);\r\n    }\r\n  };\r\n}\r\n"],"names":[],"version":3,"file":"types.d.ts.map"}